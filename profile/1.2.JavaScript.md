## План занятия (///EDIT///)

1. Компонентный подход (теория)
2. JavaScript
   1. ~~Типы данных~~
      1. Примитивные vs ссылочные
      2. Массивы
      3. Объекты
   2. ~~Основные конструкции (переменные, условия, циклы и тд)~~
   3. TypeScript
   4. Функции
3. Вынесение повторяющегося кода в компоненты
4. Свойства (properties)
5. Conditional rendering (JS → HTML)

# 1. 2. JavaScript. Теория

## Синтаксис

1. **Точка с запятой** `;`
2. **Комментарии**
   - ( однострочный - `//`)
   - (многострочный - `/* */`)
   - (выделенной области - `ctrl + /`)
3. **Объявление и инициализация переменной** ( синтаксис )
   - `let` - современный и рекомендуемый способ объявления.
   - `const` - позволяет объявить константу, т.е. **неизменяемое** значение. В JS некоторые сущности, объявленные череp `const` , все таки можно изменить.
   - `var` (deprecated) - устаревший способ объявления переменной, существующий с момента создания JavaScript.

## Типы данных (8 шт.)

- ### `String`
  Это тип данных для хранения строковых значений.
  По сути, строка — это набор букв и других символов, заключенных в кавычки. Для строк в JavaScript можно использовать кавычки трёх видов:
  - Одинарные `‘ ’`
  - Двойные `“ ”`
  - Косые \` \`
    Чтобы использовать кавычки внутри строки, нужно использовать кавычки другого типа, либо поставить обратный слэш перед кавычками внутри строки (`*\"*`). Например:
  ```jsx
  let correct1 = 'Я прохожу курс "База JavaScript"';
  let correct2 = 'Я прохожу курс "База JavaScript"';
  ```
- ### `Number`
  Это тип данных для хранения чисел. Он используется как для целых, так и для дробных чисел
  ```jsx
  let age = 23;
  let weight = 67.5;
  let temperature = -5;
  ```
- ### `Boolean`
  Это логический (булевый) тип данных. Переменная этого типа может иметь всего два значения:
  - `true` (истина)
  - `false` (ложь)
- ### `null`

  Cпециальный тип данных для хранения пустого или неизвестного значения

  ```jsx
  // У нас была машина
  let myCarName = "Toyota Corolla";

  // Но потом мы её продали и остались без машины
  myCarName = null;
  ```

- ### `undefined`
  Ещё один специальный тип данных. Он показывает, что переменная была объявлена, но значение ей не присвоено.
  Попробуем объявить переменную без присвоения значения и вывести её на консоль:
  ```jsx
  let x;
  console.log(x); *// Выведет undefined*
  ```
  В чем же отличие от `null`? В случае с `null` известно, что переменной **уже присвоено значение**. `undefined` же говорит о том, что переменная **объявлена**, но никакого значения ей **не было** присвоено.
  На практике не рекомендуется вручную задавать значение `undefined` какой-либо переменной. Если нужно явно задать пустое значение, используйте значение `null`.
- ### `Symbol`
  Используется для создания **уникальных ключей** объекта.
  Для создания переменных этого типа существует специальная одноименная функция:
  ```jsx
  const id = Symbol("id");
  ```
- ### `BigInt`
  Используется для хранения очень больших целых чисел (больше, чем (`2⁵³-1`), т.е. `9007199254740991`).
  Для создания переменной этого типа нужно поставить букву **`n`** в конце числа:
  ```jsx
  let bigNumber = 123456789n;
  ```
- ### `Object`
  Это сложный тип данных, который позволяет объединить несколько схожих параметров в одну сущность или структуру.
  `Object` объявляется с помощью фигурных скобок, внутри которых следует список пар `"key" : value`:
  ```jsx
  const car = {
  	name: "Toyota Corolla",
  	year: 2017,
  	isNew: false,
  	owner: null,
  };
  ```

## Преобразования типов (//ДОП//)

- JS имеет динамическую типизацию (присвоив переменной значение одного типа, в дальнейшем мы можем задать ей значение другого типа)
- Виды преобразований
  1. Явный
  2. Неявный
- Преобразования

  1. К строке `string`

     1. `number`→ `string`
     2. `boolean`→ `string`

     ```jsx
     // Явное преобразование:
     console.log(String(12), typeof String(12));
     console.log(String(true), typeof String(true));

     //Неявное преборазование: (Конкатенация)
     console.log(12 + "3", typeof (12 + "3")); // "123" string
     console.log(true + "", typeof (true + "")); // "true" string
     ```

  2. К числу `number`

     1. `string`→ `number`
     2. `boolean`→ `number`

     ```jsx
     // Явное преобразование:
     console.log(Number("1"), typeof Number("1"));
     console.log(Number(" "), typeof Number(" "));
     console.log(Number(true), typeof Number(true));

     //Неявное преборазование: (унарный +)
     console.log(+" ", typeof +" "); // 0 number
     console.log(+true, typeof +true); // 0 number
     const example1 = "1";
     console.log(+example1, typeof +example1); // 0 number
     console.log(Number("Hello World!")); // NaN (Not a number) number
     ```

  3. К `boolean`, **truthy и falsy-значения:**

     1. [Falsy-значения](https://developer.mozilla.org/ru/docs/Glossary/Falsy) - это значения, которые становятся `false`при преобразовании их в тип `Boolean`.

        То есть, если преобразовать переменную со значением, например, `null`к типу `Boolean`, то она будет равна `false`. Falsy-значения:

        - `null`
        - `undefined`
        - `NaN`
        - `0`
        - `-0`
        - `''` (пустая строка)
        - `false`

     2. [Truthy-значения](https://developer.mozilla.org/ru/docs/Glossary/Truthy) - это значения, которые становятся `true` при преобразовании в тип `Boolean`. В **JavaScript** все значения являются истинными, если они не определены falsy-значениями.

     ```jsx
     console.log("2: ", Boolean(2)); // true
     console.log("0 (String): ", Boolean("0")); // true
     console.log("0 (Number): ", Boolean(0)); // false
     console.log("null: ", Boolean(null)); // false
     console.log("NaN: ", Boolean(NaN)); // false
     ```

## Строки `String`, методы срок //(можно доп)//

### Создание строк

```jsx
const string1 = "JavaScript"; // Одинарные кавычки
const string2 = "JavaScript"; // Двойные кавычки
const string3 = `JavaScript`; // Косые кавычки
```

### Объединение строк в одну (конкатенация)

```jsx
const srtingJava = "Java";
const stringScript = "Script";
console.log(srtingJava + stringScript); // >> "JavaScript"
console.log(srtingJava + " " + stringScript); // >> "Java Script"
// Шаблонные строки:
const number1 = 123;
console.log(`${number1}999`); // >> "123999"
console.log(`${number1 + 7}`); // >> "130"
```

### Методы строк

```jsx
// Основные
const string = "JavaScript";

// Вычисление длины строки
console.log(string.length); // >> 10

// Получение символа по индексу
console.log(string[0]); // >> "J"

// Смена регистра
console.log(string.toUpperCase()); // >> "JAVASCRIPT"
console.log(string.toLowerCase()); // >> "javascript"
```

- **Поиск символов в строке**
  - `string.indexOf('a')`
  - `string.includes('Script')`
- **Обрезка сторки**
  - `string.slice(6, 10)`
  - `string.substring(6, 10)`
- **Замена символов**
  - `string.replace('Script', '')`
  - `string.replaceAll('a', 'A')`
- **Повторение строки**
  - `string.repeat(3)`
- **Удаление лишних пробелов (по краям)**
  - `string1.trim()`

## Массивы

### Что такое массив?

#### Массив – это набор элементов (значений). Элементы в нем могут быть как одного, так и разных типов.

> Массив можно сравнить с ящиками, в которых мы храним вещи. В одном ящике мы можем хранить, например, только футболки. В другом можем хранить канцелярию, например, ручки и тетрадки вместе.

> Однако, хоть массивы и могут содержать в себе значения разных типов, на практике они, в основном, используются для хранения однотипных данных.

- Для того, чтобы создать массив, достаточно создать какую-нибудь переменную, и в качестве значения прописать ей квадратные скобки:

`const array = [];`

Таким образом мы создали пустой массив.

- Чтобы заполнить его элементами, в квадратных скобках можно прописать необходимые значения через запятую:

`const array = [1, 2, true, 'JavaScript', 'Hello World!'];`

В итоге мы создали массив из пяти элементов с различными типами данных.

### Получение элементов массива

- Для получения элемента массива, используются квадратные скобки, в которые передается индекс необходимого элемента:

```js
const array = ["first", "second", "third", "fourth"];
console.log("item:", array[1]); // item: second
```

Итак, мы получили второй элемент, который находится под индексом 1.

- Если передать в скобки несуществующий индекс, то вернется значение `undefined`:

```js
const array = ["first", "second", "third", "fourth"];
console.log("item:", array[4]); // item: undefined
```

В данном случае мы получили `undefined`, так как элемента под индексом `4` в массиве нет. Индекс последнего элемента - это `3`.

Для того, чтобы получить последний элемент массива, можно просто передать последний индекс. Но точный индекс мы можем не знать, так как в массиве может быть сколько угодно элементов, плюс их количество может меняться. Чтобы не передавать какой-то фиксированный индекс и сделать код универсальным, нам необходимо отталкиваться от длины массива. Таким образом, чтобы получить последний элемент массива, в скобках нужно написать array.length - 1:

```js
const array = ["first", "second", "third", "fourth"];

console.log("last item:", array[array.length - 1]);
// last item: fourth

console.log("second item from end:", array[array.length - 2]);
// second item from end: third
```

В данном примере мы получили последний и предпоследний элементы массива.

## (//ДОП//)

Также, в JavaScript есть другая возможность получить элемент массива – с помощью **метода** `at()`. Данный метод принимает в себя индекс элемента, который мы хотим получить:

```js
const array = ["first", "second", "third", "fourth"];
console.log("item:", array.at(1)); // item: second
```

Таким образом мы получили второй элемент под индексом 1.

Если же мы хотим получить элемент с конца, то нужно передать отрицательное значение, например, -1. Значение -1 будет значить, что мы хотим получить первый элемент с конца массива:

```js
const array = ["first", "second", "third", "fourth"];

console.log("last item:", array.at(-1));
// last item: fourth

console.log("second item from end:", array.at(-2));
// second item from end: third
```

Таким образом мы получили первый и второй элемент с конца массива.

## (^// //^)

## Методы массивов

### Длина массива

Для того, чтобы узнать длину массива (т.е. количество элементов в нем), используется свойство `length`:

```js
const array = [1, 3, 5, 7, 9, 11];
console.log("array length: ", array.length); // 6
```

Таким образом вывелось количество чисел в нашем массиве - 6.

Обратите внимание, что получение длины массива точно такое же, как и получение длины строки.

### Добавление элементов

Если мы хотим положить еще какую-нибудь вещь в наш “ящик”, мы можем воспользоваться методами `push()` и `unshift()`.

- Метод `push()` добавляет новый элемент в <ins>конец</ins> нашего массива:

```js
const array = [1, "2", 3];
array.push("4");
console.log("array push: ", array); // [1, '2', 3, '4']
```

В конец нашего массива добавилось новое значение - `строка (string) '4'`.

- Метод `unshift()` добавляет новый элемент в <ins>начало</ins> массива:

```js
const array = [1, "2", 3];
array.unshift("0");
console.log("array unshift: ", array); // ['0', 1, '2', 3]
```

### Удаление элементов

Если мы хотим что-нибудь достать, для этого также есть два метода - `pop()` и `shift()`.

- Метод` pop()` удаляет <ins>последний</ins> элемент массива:

```js
const array = ["one", "two", "three"];
array.pop();
console.log("array pop: ", array); // ['one', 'two']
```

Как можно увидеть, в результате была удалена строка `'three'`.

Также отметим, что метод `pop()` **возвращает** значение удаленного элемента. То есть, если прописать удаление элемента в **переменную**, то ей присвоится значение удаленного элемента:

```js
const array = ["one", "two", "three"];
const deletedElement = array.pop();
console.log("array pop: ", array); // ['one', 'two']
console.log("deleted element: ", deletedElement); // 'three'
```

В результате, последний элемент из массива был удален и помещен в переменную `deletedElement`.

- Метод `shift()` удаляет первый элемент массива. В случае с `shift()` удаленный элемент также можно присвоить какой-нибудь переменной:

```js
const array = [true, false, "true", "false"];
deletedElement = array.shift();
console.log("array shift: ", array); // [false, 'true', 'false']
console.log("deleted element: ", deletedElement); // true
```

### Изменение элементов в массиве

- При изучении строк мы говорили об индексе и о том, что каждый символ строки имеет собственный индекс.

- В массиве все абсолютно также. Каждому элементу массива присваивается свой индекс - позиция элемента. Напоминаем, что индексы в массиве начинаются с нуля.

- Давайте посмотрим, как выглядит изменение элемента массива:

```js
const array = [120, 380, 250, 670];
array[1] = true;
console.log("updated array: ", array); // [120, true, 250, 670]
```

В данном примере:

1. Мы обратились к массиву array.
2. Затем прописали квадратные скобки и передали в них **индекс второго элемента** - `1`.
3. И присвоили второму элементу со значением `380` новое значение - `true`.

## (// ПОСЛЕ КОНСТРУКЦИЙ //)

## Перебор массивов с помощью for, for...of и forEach()

### Перебор с помощью for

С циклом for многие уже знакомы. Давайте посмотрим на его структуру:

```js
for (начальное значение; условие; шаг) {
  // тело цикла;
};
```

- Цикл for действует строго в следующем порядке:

1. `Начальное значение`. Выполняется один раз при входе в цикл. В нем мы задаем начальное значение для переменной.
2. `Условие.` Проверяется перед каждой итерацией (кругом) цикла. Если условие не выполняется, цикл остановится.
3. `Тело цикла.` Выполняется снова и снова, пока условие верно. В нем мы прописываем всю необходимую нам логику.
4. `Шаг.` Выполняется после тела цикла на каждой итерации перед проверкой условия. В нем мы меняем значение переменной тем или иным образом (увеличиваем, уменьшаем и т. д.)

- Давайте посмотрим, как с помощью него перебрать массив:

```js
const array = ["Java", "Script", "Hello", "World"];
for (let i = 0; i < array.length; i++) {
	console.log("array item:", array[i]);
	/*
Вывод:
array item: 'Java'
array item: 'Script'
array item: 'Hello'
array item: 'World'
*/
}
```

- Итак, что мы сделали:

1. Создали массив array с четырьмя строчными элементами.
2. Прописали цикл for, в котором создали переменную i со значениями от 0 до array.length (длина массива) и с шагом в единицу. Соответственно, в нашем случае i будет принимать такие значения: 0, 1, 2, 3.
3. В теле цикла мы выводим каждый элемент массива. Как получить элемент массива мы уже знаем: обращаемся к массиву, пишем квадратные скобки и передаем в них нужный индекс. В нашем случае индекс - это i.

## Логические конструкции

### Условный оператор `if... else if... else...`

- Условный оператор (`if`) – если условие выполнится, то сделать какое-либо действие:

```js
const number = 5;

// Передаем выражение
if (number < 10) {
	// Выполнится, так как 5 < 10 === true
	console.log(`Число ${number} меньше 10!`);
}

const string = "";
if (string.length > 0) {
	// Не выполнится
	console.log("Строка содержит текст!");
}
```

Второй `console.log()` не сработал, так как выражение в круглых скобках вернуло `false`. Также последний пример можно записать немного по-другому

```js
const string = "";
if (string.length) {
	// Не выполнится
	console.log("Строка содержит текст!");
}
```

- `if...else` – более расширенная запись предыдущей конструкции. В блоке `else` можем указывать код, который должен выполниться, если условие не сработает (выражение вернет `false` или `falsy-значение`).

```js
const condition = 5 > 10; // вернет false
if (condition) {
	console.log("Выражение истино!");
} else {
	console.log("Выражение ложно!");
}
// Вывод: Выражение ложно!

const string = "";
if (string.length) {
	console.log("Строка содержит текст!");
} else {
	console.log("Строка пустая!");
}
// Вывод: Строка пустая!
```

- `else if` – дополнительная проверка условия:

```js
const status = "online";
if (status === "online") {
	console.log("Ваш статус: в сети");
} else if (status === "offline") {
	console.log("Ваш статус: не в сети");
} else {
	console.log("Ошибка! Неизвестный статус!");
}
// Вывод: Ваш статус: в сети
```

### Условный оператор `switch`

- `switch` - сравнивает выражение со случаями (кейсами), находит тот, значение которого совпадает с выражением, и затем выполняет инструкции нужного случая.

```js
switch (переменная) {
	case значение1:
		// выполнится, если переменная === значение1
		break; // завершение случая
	case значение2:
		// выполнится, если переменная === значение2
		break;
	default:
		// выполнится, если ни один другой случай не сработал
		break;
}
```

- В круглых скобках после `switch` указывается переменная / значение, которое будем сравнивать. Ниже указываем случаи при помощи ключевого слова `case`. Если переменная / значение после `switch` будет равна значению из `case`, то он выполнится. Если ни один `case`, не выполнится, то выполнится `default`.

```js
const status = "online";
switch (status) {
	case "online":
		console.log("Ваш статус: в сети");
		break;
	case "offline":
		console.log("Ваш статус: не в сети");
		break;
	default:
		console.log("Ошибка! Неизвестный статус!");
		break;
}
// Вывод: Ваш статус: в сети
```

### Тернарный оператор `... ? ... : ... ` - компактная замена `if...else`:

- Если условие истинно, то вернется `выражение1`, а если ложно, то `выражение2`. Примеры:

```js
const num = 7;
console.log(num === 7 ? "Число 7" : "Число не 7"); // 'Число 7'
console.log(num === 10 ? "Число 10" : "Число не 10"); // 'Число не 10'

// Запись в переменную
const text = num > 42 ? "Число больше 42" : "Число меньше 42";
console.log(text); // 'Число меньше 42'
```

## Логические операторы

### И (AND) - &&

- Если все операнды (аргументы операции) типа `Boolean`, то результатом будет `true`, когда **все** операнды равны `true`. В остальных случаях результатом будет `false`.

```js
console.log(true && false && true); // false
console.log(true && true && true && true); // true
```

- Представим, что мы делаем интернет-магазин. Для заказа необходима авторизация и возраст ≥ 18 лет. Это 2 условия, которые должны быть обязательно выполнены:

```js
const isAuth = true; // Переменная, авторизован ли пользователь
const age = 25; // Возраст

if (isAuth && age >= 18) {
	// Попадем сюда, если все условия выполнятся
}
```

- Если операнды не только типа `Boolean`, то:

  - Если все значения `truthy` (приводятся к `true`), то возвращает последнее из них.

  - Если хотя бы одно `falsy` (приведется к `false`), то возвращает первое из них.

```js
// Все truthy
console.log(1 && "hello" && true); // true
console.log(true && 1 && "javascript"); // 'javascript'

// Содержится falsy
console.log(false && 0 && "javascript"); // false
console.log(1 && "" && false); // ''
console.log(0 && "" && false); // 0
```

### ИЛИ (OR) - ||

- Если все операнды типа `Boolean`, то результатом будет `true`, когда один или несколько операндов равны `true`. В остальных случаях (только когда все операнды `false`) результатом будет `false`.

```js
console.log(false || true || false); // true
console.log(false || false); // false
```

- Представим, что мы делаем программу-фильтр для входящих звонков. Если звонит Игорь или Алексей, тогда звонок переадресовывается на наш телефон и мы ответим. В другом случае вызов сбрасывается:

```js
const incomingName = "Игорь";

if (incomingName === "Игорь" || incomingName === "Алексей") {
	// Звонок проходит дальше
} else {
	// Сброс вызова
}
```

- Если операнды не только типа Boolean, то:

  - Если все значения `falsy` (приводятся к `false`), то возвращает последнее из них.

  - Если хотя бы одно `truthy` (приведется к `true`), то возвращает первое из них.

```js
// Все falsy
console.log("" || 0 || false); // false
console.log(false || 0 || ""); // ''

// Содержится truthy
console.log(false || "hello" || true); // 'hello'
console.log(1 || false || "javascript"); // 1
console.log(true || 1 || "javascript"); // true
```

- Это может быть полезно, когда мы хотим установить значение по умолчанию. Пример:

```js
const userString = prompt("Введите строку");
console.log(userString || "default string");
```

### HE (NOT) - !

- Оператор НЕ при работе с типом данных `Boolean` превращает `true` в `false` и наоборот. Если операнд будет любого другого типа данных, то, если его можно преобразовать к `true`, вернет `false`, а иначе – `true`.

```js
console.log(!true); // false
console.log(!false); // true
console.log(!""); // true
console.log(!0); // true
console.log(!1); // false
console.log(!"hello"); // false
```

## (// ДОП //)

### Оператор нулевого слияния (Nullish coalescing) - ??

- Данный оператор очень похож на `ИЛИ (||)`, но он считает за `falsy` только `null` и `undefined`. То есть он возвращает правый операнд, если слева был `null` или `undefined`, и возвращает левый, если их там не было.

```js
console.log(null ?? "123"); // '123'
console.log(undefined ?? "123"); // '123'
console.log(false ?? "123"); // false
console.log(0 ?? "123"); // 0
console.log(true ?? "123"); // true
```

- Используя оператор `ИЛИ (||)` для установки значения по умолчанию, нам иногда не нужно исключать все `falsy-значения` (например `0`, `false`, `""`, `NaN` и т. д.), это вполне нормальные значения, которые мы тоже можем захотеть использовать. Чтобы их не игнорировать, нам нужно было добавлять дополнительные проверки:

```js
const number = 0;
console.log(number || "Числа нет");
// Вывод: 'Числа нет' (хотя 0 это число)

// Нужна дополнительная проверка:
console.log(number || number === 0 ? number : "Числа нет"); // Вывод: 0

// Или проще:
console.log(number ?? "Числа нет"); // Вывод 0
```

## Циклы

### Цикл `while`.

- Циклы также есть во всех языках программирования. Они представляют из себя повторяющуюся последовательность действий и состоят из условия и тела цикла. Каждое повторение цикла называется итерацией.

- В работе мы часто можем встретиться с задачами, где нужно использовать циклы (например, перебор какого-то списка). До выполнения программы мы не всегда можем знать, сколько элементов находится в списке и сколько нужно перебирать. Здесь на помощь приходят циклы, с помощью которых мы сможем выполнять какие-либо действия с элементами, пока выполняется условие (выполнять, пока не закончатся элементы списка).

```js
while (условие) {
	// цикл будет повторяться, пока условие истинно
}
```

```js
let i = 0;
while (i < 5) {
	console.log(i);
	i++;
}

/* 
  Вывод: 
  0
  1
  2
  3
  4
*/
```

- Цикл выполняется 5 раз, переменная `i` меняет свое значение на каждой итерации и принимает значения от 0 до 5. Когда `i` становится 5, цикл прекращает свое выполнение. Так как переменную мы выводим только в теле цикла, значение 5 уже не выведется.

- Рассмторим другой пример. В условиях циклов также, как и в `if` , работает преобразование типов.

```js
let i = 5;
while (i) {
	// приведение типов в условии цикла
	console.log(i);
	i--;
}
/* 
  Вывод: 
  5
  4
  3
  2
  1
*/
```

- Здесь мы в условие передали число. Все числа преобразуются в `true`, но когда `i` доходит до значения `0`, оно преобразовывается в `false`. Поэтому на этом цикл прекращает свое выполнение.

### Цикл `do ... while`.
